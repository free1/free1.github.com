<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
    <meta name="author" content="Free" />
    <meta name="generator" content="Jekyll 1.0.2" />
    <meta name="description" content="Ruby" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    
    <link rel="stylesheet" type="text/css" href="/css/post.css" media="all" />

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>

    <script type="text/javascript" src="/js/compatible.js"></script>

</head>
	<body>
		<div id="Previous">
			<a href="http://free1.github.com/"> <-Home </a>
		</div>

		<div id="Title">
	    	<h1>方法规则</h1>
	    	<p><b>03 Jun 2013</b>, by <b>Free</b></p>
		</div>

		<div id="Post">
	    	<article id="articlePost">
	        	<h2>方法返回值</h2>

<ul>
<li>如果return后面没有任何表达式，返回值为nil。</li>
<li>方法的最后一行可以省略return关键字。</li>
<li>方法可以返回多个值，显式使用return语句，并把返回值用逗号隔开；或者直接用一个数组作为返回值(并行赋值时采用这种方法定义)。</li>
</ul>

<h2>单键方法(给单个对象添加一个方法，与类方法差不多)</h2>

<ul>
<li>在def关键字后加上一个求值结果为对象的表达式，表达式之后一个句点符号和要定义的方法名。<br></li>
</ul>

<p>特殊方法是指某实例所特有的方法。一个对象有哪些行为由对向所属的类决定，但是有时候，一些特殊的对象有何其他对象不一样的行为，在多数程序设计语言中，例如C++和Java，我们必须定义一个新类，但在Ruby中，我们可以定义只从属于某个特定对象的方法，这种方法我们成为特殊方法(Singleton Method)。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class SingletonTest
    def info
        puts “This is This is SingletonTest method”
    end
end

obj1 = SingletonTest.new
obj2 = SingletonTest.new

def obj2.info
    puts “This is obj2″
end

obj1.info
obj2.info
</code></pre></div>
<p>执行结果为：<br>
This is This is SingletonTest method<br>
This is obj2   </p>

<p>有时候，我们需要给一个对象定义一系列的特殊方法，如果按照前面的方法，那么只能一个一个定义：   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def obj2.singleton_method1
end

def obj2.singleton_method2
end

def obj2.singleton_method3
end
……
def obj2.singleton_methodn
end
</code></pre></div>
<p>这样做非常繁复麻烦，而且无法给出一个统一的概念模型，因此Ruby提供了另外一种方法，   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class &lt;&lt; obj
……
end

obj是一个具体的对象实例，class &lt;&lt; 代表它的特殊类。

class SingletonTest
  def meth1
   puts “This is meth1″
  end

  def meth2
   puts “This is meth2″
  end
end

obj1 = SingletonTest.new
obj2 = SingletonTest.new

class &lt;&lt; obj2
  def meth1
   puts “This is obj2′s meth1″
  end

  def meth2
   puts “This is obj2′s meth2″
  end
end

obj1.meth1
obj1.meth2
obj2.meth1
obj2.meth2
</code></pre></div>
<p>执行结果为：<br>
This is meth1<br>
This is meth2<br>
This is obj2′s meth1<br>
This is obj2′s meth2   </p>

<h2>方法名</h2>

<ul>
<li>通常以小写字母打头，超过一个单词使用下划线。</li>
<li>命名习惯1：方法名以问号结尾表示一个判断的方法，通常返回true或false。</li>
<li>命名习惯2：方法名以感叹号结尾，比如Array对象又一个sort方法，这个方法产生一个该数组的拷贝，然后在这个拷贝上进行排序；还有一个sort！方法，它对这个数组本身排序。</li>
</ul>

<h2>方法别名</h2>

<ul>
<li>alias aka also<em>known</em>as，执行完后，aka标示符与also<em>known</em>as引用同一方法(可为一个方法增加新的功能)。</li>
<li>当新方法被重新定义时，老方法不会改变，这个特性可以用来使用环绕别名的技巧:<br></li>
</ul>

<ol>
<li>给方法定义一个别名。<br></li>
<li>重定义这个方法。<br></li>
<li>在新的方法中定义老的方法。<br></li>
</ol>

<h2>参数默认值</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">在参数名后加入等号和默认值。
(参数默认值可以是常量，表达式，实例变量的引用，前面定义参数的引用)   
def prefix(s, len=1)   
    s[0,len]   
end   
</code></pre></div>
<h2>可变长度参数列表和数组(*,&amp;在参数列表中只能有一个)</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">接收任意参数，在参数前加*符：(打头的参数要放在带有默认值参数的后面，
其后可以再指定普通参数，但该普通参数需要放在&amp;打头参数之前，&amp;参数必须在最后)。   

def max(first, *rest)   
    max = first   
    rest.each { |x| max = x if x &gt; max }   
    max   
end   
</code></pre></div>
<h2>代码块参数</h2>

<p>yield方式:    </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def s(n, m, c)   
    i = 0   
    while(i &lt; n)   
        yield i*m+c   
        i += 1   
    end   
end    
s(5,3,3) {|x| puts x}   
</code></pre></div>
<p>Proc的call方式:   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def s(n, m, c，&amp;b)   
    i = 0   
    while(i &lt; n)   
        b.call(i*m+c)   
        i += 1   
    end   
end   
s(5,3,3) {|x| puts x}   
</code></pre></div>
<h2>动态调用方法</h2>

<ul>
<li>使用send：obj.send(:method, 3) ，第一个参数为方法名，剩下的参数直接传递给调用的方法。还有public_send()，前者可以调用私有方法。<br></li>
</ul>

<h2>动态定义方法(使用 define_method )</h2>

<p>事例代码:   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class MyClass   
    define_method :my_method do |my_arg|   
        my_arg * 3   
    end   
end   

obj = MyClass.new   
obj.my_method(2)   # =&gt; 6     
</code></pre></div>
	    	</article>

	    	
				<div style="height: 64px"></div>
    		
		</div>
		
	</body>
</html>


 
   
       