<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
    <meta name="author" content="Free" />
    <meta name="generator" content="Jekyll 1.0.2" />
    <meta name="description" content="Test" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    
    <link rel="stylesheet" type="text/css" href="/css/post.css" media="all" />

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>

    <script type="text/javascript" src="/js/compatible.js"></script>

</head>
	<body>
		<div id="Previous">
			<a href="http://free1.github.com/"> <-Home </a>
		</div>

		<div id="Title">
	    	<h1>RSpec基础</h1>
	    	<p><b>25 Aug 2013</b>, by <b>Free</b></p>
		</div>

		<div id="Post">
	    	<article id="articlePost">
	        	<p><a href="https://www.relishapp.com/rspec/rspec-rails/docs">rspec文档</a><br>
<a href="https://github.com/rspec/rspec-rails">rspec源码</a></p>

<h2>命令行运行测试</h2>

<ul>
<li>安装rspec：
$ rails generate rspec:install</li>
<li>生成测试需要的代码文件：
$ rails generate integration<em>test static</em>pages</li>
<li>迁移数据库：
$ bundle exec rake db:migrate<br></li>
<li>测试准备：
$ bundle exec rake test:prepare</li>
<li>运行测试：
$ bundle exec rspec spec/models/user_spec.rb</li>
<li>创建“测试数据库”：
$ bundle exec rake test:prepare</li>
</ul>

<h2>let 方法(定义局部变量)</h2>

<p>我们可以使用 RSpec 提供的 let 方法便捷的在测试中定义局部变量。let 方法的句法看起来有点怪，不过和变量赋值语句的作用是一样的。let 方法的参数是一个 Symbol，后面可以跟着一个块，块中代码的返回值会赋给名为 Symbol 代表的局部变量。也就是说：</p>

<p><code>let(:name) {expression}</code>格式   </p>

<p>跟before里的代码一样的，但是比before里的代码效果更好。   </p>

<p><code>let(:found_user) { User.find_by(email: @user.email) }</code></p>

<p>定义了一个名为 <code>found_user</code> 的变量，其值等于 <code>find_by</code> 的返回值。在这个测试用例的任何一个 before 或 it 块中都可以使用这个变量。使用 let 方法定义变量的一个好处是，它可以记住变量的值。对上面的代码而言，因为 let 的备忘功能，<code>found_user</code> 的值会被记住，因此不管调用多少次 User 模型测试，<code>find_by</code> 方法只会运行一次。</p>

<h2>describe和context方法</h2>

<p>describe和context方法用来组织相关的行为example。
使用一个字符串作为他们的参数，以及使用一个block来定义其上下文的范围。
写model的spec或者其他的unit test时，可以传一个Ruby类作为describe的第一个参数。Doing so also creates an implicit subject for the examples.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe Timesheet do
  ...
end
</code></pre></div>
<p>describe可以嵌套<br>
一般使用：   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe Timesheet do
  describe “#test” do
    ...
  end
end
</code></pre></div>
<p>这样的方式（注意第一个describe的参数是一个类，第二个describe参数是以#开始)这个表示测试Timesheet类下面的test方法)</p>

<h2>its方法</h2>

<p>它和 it 很像，不过测试对象是参数中指定的属性而不是整个测试的对象。   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">its(:remember_token) { should_not be_blank }
</code></pre></div>
<p>等同于：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">it { expect(@user.remember_token).not_to be_blank }
</code></pre></div>
<h2>before和after方法</h2>

<p>和setup、teardown方法类似<br>
Before and after code can be inserted in any describe or context blocks, and by default the execute for each it block that shares their scope.</p>

<p>before { visit root_path } 链接，创建实例</p>

<h2>it方法</h2>

<p>it方法使用一个描述和block。一个it就是一个测试，最好一个it一个期望<br>
As mentioned, the idea is to complete the thought that was started in the describe method, so that it foms a complete sentence.</p>

<h2>specify方法</h2>

<p>specify是it方法的别名，但是他可以使用不同的结构来增加可读性。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe BlogPost do
  set(:blog_post) {blog_post = BlogPost.new}
  specify {blog_post.should_not be_published}
end
</code></pre></div>
<p>生成的RSpecDoc如下：
BlogPost
- should not be published</p>

<h2><code>shared_examples_for</code>方法与<code>it_should_behave_like</code>方法来消除重复</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">subject { page }

  shared_examples_for &quot;all static pages&quot; do
    it { should have_content(heading) }
    it { should have_title(full_title(page_title)) }
  end

  describe &quot;Home page&quot; do
    before { visit root_path }
    let(:heading)    { &#39;Sample App&#39; }
    let(:page_title) { &#39;&#39; }

    it_should_behave_like &quot;all static pages&quot;
    it { should_not have_title(&#39;| Home&#39;) }
  end
</code></pre></div>
<h2>expect方法</h2>

<p>expect 用来改变一个值或者抛出一个异常。后面接change来表示要达到的值，使用raise_error(异常类)来表示会抛出一个异常。<br>
change 方法可接受两个参数，第一个参数是对象名，第二个是 Symbol。change 方法会在 expect 块中的代码执行前后，分别计算在第一个参数上调用第二参数代表的方法返回的结果</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">expect {
BlogPost.create :title =&gt; “Hello”
}.to change {BlogPost.count}.by(1)
</code></pre></div>
<p>希望在expect块里做完之后，BlogPost.count的值要改为1
改变值的例子</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe Order do
  let(:order) {order = Order.create}
  describe &quot;#ship!” do
    context “with paid” do
      it &quot;should update status to shipping&quot; do
        expect {
          order.ship!
          }.to change { order.status }.from(“new”).to(“ship”)
       end
    end
end
</code></pre></div>
<p>这里改变值使用的from和to，这样就会在执行expect块之前检查order.status的值是不是new，并且会在执行之后检查是不是”ship”值
抛出异常的例子</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe Order do
  let(:order) {order = Order.create}
  describe &quot;#ship!” do
    context “with paid” do
      it &quot;should raise NotPaidError&quot; do
        expect {
          order.paid? = flase
          order.ship!
          }.to raise_error(NotPaidError)
       end
    end
end
</code></pre></div>
<p>这里表示执行完except块之后会抛出一个NotPaidError异常。</p>

<h2>pending方法</h2>

<p>可以使用pending来列出打算要写的测试
使用it函数不传block给他也是pending的意思，也可以在block离调用pending</p>

<p>可以在before里写pending</p>

<h2>should和should_not方法</h2>

<p>Rspec mixes them into the base Ruby Object class at runtime so that they are available on all objects.They expect to receive Matcher objects, generated using Rspec expectation syntax   </p>

<p>检查型别、方法:   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">receiver.should be_true
receiver.should be_false
receiver.should be_nil
</code></pre></div>
<p>检查Array、Hash:   </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">receiver.should be_a_kind_of(Array)
receiver.should be_an_instance_of(Array)
receiver.should responsed_to(:foo)

receiver.should have_key(:foo)
receiver.should include(4)
receiver.should have(3).items
</code></pre></div>
<p>任何be_开头:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">receiver.should be_empty
receiver.should be_blank
receiver.should be_admin
receiver.should be_valid 是否合法
</code></pre></div>
<p>should == 是万能的
Rspec的Matcher很多，也可以自己写</p>

<h2>Implicit Subject和Explicit Subject</h2>

<p>使用subject可省略receiver</p>

<h2>its</h2>

<p>its可以省略receiver的方法调用</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe Order do
  subject { Order.new}
  its(:status) {should == “New”}
end 
</code></pre></div>
<h2>controller的测试(基本三段式)</h2>

<ul>
<li>初始化参数</li>
<li>请求方法</li>
<li>返回render or redirect_to</li>
</ul>

<h2>常用方法</h2>

<ul>
<li>visit &#39;&#39; 测试链接</li>
<li>have_selector（）是否包含</li>
<li>eq 测试对象是否相同</li>
<li>subject { page } 变量,设为这些测试用例默认的测试对象</li>
<li>respond_to（）如果对象可以响应指定的方法或属性就返回 true，否则返回 false</li>
<li>.dup（）复制</li>
<li>.upcase() 转换成全部大写字母的形式</li>
<li>have_selector 会检查页面中是否出现了指定的元素</li>
</ul>

<h2>代码实例:</h2>

<ul>
<li>view页面测试例子(测试页面中是否包含了正确的内容):</li>
</ul>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe &quot;Home page&quot; do

  it &quot;should have the content &#39;Sample App&#39;&quot; do
    visit &#39;/static_pages/home&#39;
    expect(page).to have_content(&#39;Sample App&#39;)
  end

end
</code></pre></div>
<p>运行：$ bundle exec rspec spec/requests/static<em>pages</em>spec.rb</p>

<ul>
<li>model中测试例子:</li>
</ul>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe User do

  before { @user = User.new(name: &quot;Example User&quot;, email: &quot;user@example.com&quot;) }

  subject { @user }

  it { should respond_to(:name) }
  it { should respond_to(:email) }
end
</code></pre></div>
<ul>
<li>用户注册：</li>
</ul>
<div class="highlight"><pre><code class="text language-text" data-lang="text">describe &quot;signup&quot; do

    before { visit signup_path }

    let(:submit) { &quot;Create my account&quot; }

    describe &quot;with invalid information&quot; do
      it &quot;should not create a user&quot; do
        expect { click_button submit }.not_to change(User, :count)
      end
    end

    describe &quot;with valid information&quot; do
      before do
        fill_in &quot;Name&quot;,         with: &quot;Example User&quot;
        fill_in &quot;Email&quot;,        with: &quot;user@example.com&quot;
        fill_in &quot;Password&quot;,     with: &quot;foobar&quot;
        fill_in &quot;Confirmation&quot;, with: &quot;foobar&quot;
      end

      it &quot;should create a user&quot; do
        expect { click_button submit }.to change(User, :count).by(1)
      end
    end
end
</code></pre></div>
	    	</article>

	    	
				<div style="height: 64px"></div>
    		
		</div>
		
	</body>
</html>


 
   
       