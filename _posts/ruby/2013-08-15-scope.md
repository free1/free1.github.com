---
layout: post
title: 作用域
category: ruby
description: Ruby
disqus: false
---


```
v1 = 1   

class MyClass   

    v2 = 2   

    local_variables        # => [:v2]   

    def my_method
        v3 = 3   
        local_variables   
    end

    local_variables        # => [:v2]   

end   

obj = MyCalss.new    
obj.my_method              # => [:v3]   
obj.my_method              # => [:v3]   
local_variables            # => [:v1, :obj]   
```

* 全局变量: 可以在任何作用域中访问，尽量少使用。   
* 顶级实例变量: 可以代替全局变量，但更加安全。   

## 共享作用域   

```
my_var = "Success"

class MyClass
    # 需要打印my_var...

    def my_method
        # 需要打印my_var...
    end
end
```

重写后可以完成:   

```
my_var = "Success"

MyClass = Class.new do
    puts "#{my_var}"

    define_method :my_method do
        puts "#{my_var}"
    end
end

MyClass.new.my_method

```

## instance_eval()

```
class MyClass
    def initialize
        @v = 1
    end
end

obj = MyClass.new
obj.instance_eval do
    self
    @v                 # => 1
end

v = 2
obj.instance_eval { @v = v }
obj.instance_eval { @v }       # => 2
```

以上三行代码在同一个扁平作用域中执行，因此它们都可以访问局部变量v，由于块把运行它的对象作为self，所以它们也能访问obj的实例变量@v。   
`instance_exec()` 与上面方法类似，但允许对块传入参数。  

如果在一个实例上调用了`instance_eval`，就可以在其中定义该实例的单态函数 `singleton_method`   

```
class A
end

a = A.new
a.instance_eval do
    self  # => a
    # current class => a's singleton class
    def method1
        puts 'this is a singleton method of instance a'
    end
end

a.method1
#=> this is a singleton method of instance a

b = A.new
b.method1
#=>NoMethodError: undefined method `method1' for #<A:0x10043ff70>
``` 

因为类class本身也是Class类的一个实例，instance_eval也可以用在类上，这个时候就可以在其中定义该类的singleton_method，即为该类的类函数。换句话说，可以用instance_eval来定义类函数class method。   

```
class A
end

A.instance_eval do
    self  # => A
    # current class => A's singleton class
    def method1
        puts 'this is a singleton method of class A'
    end
end

A.method1
#=> this is a singleton method of class A
```




