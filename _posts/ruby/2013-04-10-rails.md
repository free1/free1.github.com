---
layout: post
title: Rails基础
category: ruby
description: Rails
disqus: false
---

## 常用rails命令例子
* 创建rails程序并不带自身测试： rails new sample_app --skip-test-unit
* 指定rails版本创建项目：`rails  _版本号_ new` 项目名称   
* 创建脚手架：rails generate scaffold User name:string email:string
* 生成控制器代码：rails generate controller FooBars baz quux  (--no-test-framework加上不生成测试所用代码)
* 撤销控制器代码：rails destroy  controller FooBars baz quux
* 生成模型代码：rails generate model Foo bar:string baz:integer
* 撤销模型代码：rails destroy model Foo
* 查看关于数据库的rake任务：bundle exec rake -T db
* 查看所有rake任务：bundle exec rake -T
* 迁移数据库：rake db:migrate
* 在命令行使用开发数据库：sqlite3 -line db/development.sqlite3
* 离开开发数据库：.quit
* 撤销迁移数据库：rake db:rollback
* 安装gem：bundle install --without production 不包括生产环境

## 数据库操作常见方法(一般用在控制器中)
* find(尽量少用)                    查找
* order("published_at desc")       排序(接收sql语句)
* limit(10)                        限制纪录数量(数字)
* where("published_at <= ?", Time.now)    查找纪录条件(接收sql语句，问号中的内容)
* includes(:comments)                     包含关联的模型(:模型名) 
* joins(:products)                        连接关联的模型(:模型名) 
* includes 是 ActiveRecord 中辅助多表查询的方法，除了 includes 还有 joins，区别是 select 部分不同。 
* group                            分组
* offset                           偏移量(数字从第几个开始)

## Rails中扩大链接可点击范围

```
<a href="<%= user_path(current_user) %>">
	<%= gravatar_for current_user, size: 52 %>
</a>
```

## 数据库操作常见方法(一般放到模型中)
* scope              定义一个类方法完成查询，使其可以在控制器中调用，使用lambda可以使方法传递参数

```
class Shirt < ActiveRecord::Base
  scope :colored, lambda { |color| where(:color => color) }
end

Shirt.colored('puce')
```

## 路由中member与collection区别:
* member 方法作用是，设置这两个动作对应的 URL 地址中应该包含用户的 id，例如: /users/1/following生成 `following_user_path(1)`
* 如果是show edit这种只处理一个。　就是member。
* collection 方法，但 URL 中就没有用户 id 了，例如: /users/tigers生成 `tigers_users_url`
* 如果index　`bulk_edit` 这样一次操作多个。就是collection。


* 当情况复杂时，可以创建类方法

getter(获取) && setter(设置):（相对于数据库来说）   
	
  ruby:   

	def method   

	end     

	def method=(args)   

	end   
  
  java:   
  
	public String getName() {   

	        return this.name;   

	}   

	public void setName(String name) {   

	        this.name = name;   

	}

save：rails中的save其实是 `create_or_update` ，新建或修改记录！不一定是新建。   
new ：只是在内存中新建一个对象，操作数据库要调用save方法。   
create = new + 执行sql。   
build：与new基本相同，多用于一对多情况下。   
!：new!, create!, build!与new, create,    build的区别是带!的方法会显示validate的错误信息，如果验证失败会抛出导常(主要的是不跳过验证)。   
save是实例方法，而create, build, new是模型类的类方法   

`before_save和before_create` 最大的一个区别就是，`update` 也算是 `before_save` 。    


Gemfile中：   
>= 总会升级到最新版；~> 3.2.2 只会升级补丁版本的更新（例如从 3.2.1 到 3.2.2），而不会升级到次版本或主版本的更新（例如从 3.2 到 3.3）   


当migrate文件比较复杂时，可以这样整理:   
直接新建一个 migration，把 schema.rb 里的内容拷到 setup 里，然后把老的所有 migration 文件删掉。重新 migrate 一下更新 schema.rb。   


:if => `:new_record?`   
报密码不能为空可能是你有一个虚拟的password属性。比如你用了什么auth类的gem，或者你自己加了一个attr_accessor :password。然后又有validates :password这样的验证。那么，当你是从数据库中取出记录User.find(params[:id])的时候，这个属性还是nil。你只修改name的话，就会报invalid了。   

```
HTTP 请求 	URI 	动作 	                 具名路由 	作用   
GET 	      /users 	index 	               users_path 	显示所有用户的页面
GET 	      /users/1 	show 	               user_path(user) 显示某个用户的页面
GET 	    /users/new 	new 	               new_user_path 	创建（注册）新用户的页面
POST 	     /users 	create              	users_path 	创建新用户
GET 	 /users/1/edit 	edit 	          edit_user_path(user) 编辑 id 为 1的用户页面
PUT 	    /users/1 	update          	user_path(user) 更新用户信息
DELETE 	   /users/1 	destroy 	     user_path(user) 	删除用户
```