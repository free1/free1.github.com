---
layout: post
title: 共识算法
category: blockchain
description: blockchain
disqus: false
---

## 简介
* 普通的分布式计算系统中可能存在一些问题，比如节点间通讯的信道不安全，出现作恶节点，节点增多后容不下新节点的加入等，所以在分布式场景下节点达成完全一致性基本是不可能的。于是人们就开始根据FLP定理和CAP定理设计共识算法，基于区块链设计的各种共式机制都可以看作牺牲了一部分代价来换取相对的一致性。
* 区块链解决了在不可信信道上传输可信信息、价值转移的问题，而共识机制解决了区块链如何在分布式场景下达成一致性的问题。区块链的伟大之处就是它的共识机制在去中心化的思想上解决了节点间互相信任的问题。区块链能在众多节点达到一种较为平衡的状态也是因为共识机制。尽管密码学占据了区块链的半壁江山，但是共识机制是保障区块链系统不断运行下去的关键。
* 所有区块链本质上都是一种由交易驱动的确定性状态机，共识是商定确定性交易顺序和过滤无效交易的过程。


## POW(Proof Of Work，工作量证明)
* 目前比特币和以太坊使用了POW共识算法，POW可以简单理解为节点在处理交易数据的同时不断进行哈希计算，当有节点运算出符合要求的nonce值时，它就会把打包好的区块发布出去，其它节点收到区块后会进行验证，验证通过后会一致性认为该区块添加到了区块链上。
* ​寻找合理哈希是一个概率事件，当节点拥有占全网n%的算力时，该节点即有n/100的概率找到符合要求的哈希值。因为总是会有新节点加入进来，造成计算结果会越来越早的被找到，所以加入了难度值difficulty来进行调整，难度值根据全网的算力调整要求哈希值，要求哈希值前面0越多节点运算出符合要求的哈希值越难，这样就可以控制节点的出块速度基本稳定在一个时间范围内。
* 通过算力的比拼牺牲了一部分最终一致性（因为会有分叉的产生）并且需要等待多个确认，但是这种简单暴力的方法却保证了整个区块链系统的合法性，而且把区块链系统的健壮性提升到极致，就算全网只剩下一个节点运行，这个区块链系统还是会继续运行下去。
* 由于网络延迟等问题，有时候可能会出现多个节点都发布出符合要求哈希值的区块（即分叉），所以每一个节点总是选择并尝试延长代表累计了最大工作量证明的区块链，也就是最长的或最大累计工作的链，只要所有的节点选择最长累计工作的区块链，整个网络最终会收敛到一致的状态。
* 生成Coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle Tree算法生成Merkle Root Hash
* 把Merkle Root Hash及其他相关字段组装成区块头，将区块头的80字节数据（Block Header）作为工作量证明的输入
* 不停的变更区块头中的随机数即nonce的数值，并对每次变更后的的区块头做双重SHA256运算（即SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。
* POW有完全去中心化，节点自由平等，代码容易实现，破坏系统花费的成本巨大的优点。但也有对节点的性能网络环境要求高，无法达成最终一致性，浪费资源严重的缺点。


## POS(Proof Of Stake，股权证明) 
* 目前使用纯POS共识机制的公有链并不多，Nxt（未来币）是第一个100%的股权证明（PoS）机制的电子货币，也证明了纯POS共识机制可以平稳的运行。以太坊大都会阶段也打算将POW切换到POS机制。POS可以简单的理解为根据钱包里面币的多少以及币在钱包里存在的天数来合成一个单位，它根据这个关系对计算机进行哈希计算降低了难度，把钱包和区块链系统的一致性绑定在一起，钱包里的指数越大谁拥有记账权的概率就越大。
* 在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币。
* SHA256（SHA256（Bprev）,A ,t）≤balance(A)m，这其中，H为某个哈希函数；t为UTC时间戳；Bprev指的是上个区块；balance(A)代表账户A额余额。唯一可以不断调整得到参数是t，等式右边m是某个固定的实数，因此，当balance(A)越大，找到合理t的概率越大，网络中，普遍对t的范围有所限制，如可以尝试的时间不能超过标准时间戳1小时，也就是一个节点可以尝试7200次，来找到一个符合条件的t。因此在PoS中，一个账户的余额越多，在同等算力下，就越容易发现下一个区块。
* Nxt不再通过消耗大量的资源“挖矿”产生新币，而是通过现有账户的余额去“锻造”区块，这个方式称为透明锻造（Transparent Forging），并给与成功“锻造”区块的账户交易费用奖励，锻造只赚取系统中的交易手续费，不会导致供应量增加或通胀。透明锻造协议中的透明性将允许用户的客户端来决定哪个节点将会产生下一个区块。其它的节点可以直接将交易发送至该节点。而且这也允许额外的费用优先于交易而立刻实现。使用透明锻造的方式生产新区块，理论上1分钟一个区块。每个区块最多可包含255个交易。
* POS有着节省资源，避免了51%攻击，并且可以在智能手机或者树莓派这样的小型设备上运行的优点。但也牺牲了一部分的共识（同样分叉），而且需要等待多个确认，出块权利相对集中更加中心化的缺点。


## Nxt透明锻造
* NXT使用了账户余额（balance）,而非输入/输出来处理账户。它同样使用了区块结构来记录交易，但交易的验证机制与比特币完全不同。
* 每一个区块都有一个generationSignature参数，它是由产生这个区块的用户用自己的私钥对前一个区块的generationSignature签名产生的。
* 一个激活的NXT节点会不断地检测网络中有无新的有效区块产生，当检测到有新的有效区块产生时，它就对该区块的generationSignature参数进行私钥签名，之后计算这个签名的SHA256哈希，该64字节哈希的前8个字节被取出并写入一个叫hit的变量中，这个hit是对区块产生有决定作用的一个伪随机数。
* 之后节点会根据 hit/(BaseTarget * balance)-elapsedTime 计算出自己产生下一个区块的时间（期望时间）并向全网广播。
* 每个激活的账号都对应一个不断变化的target变量，该变量是表示该账号产生区块机会大小的一个指标，target与账号有效NXT余额成正比，并且与消逝时间（当前时间-前有效区块的时间戳）成正比。而BaseTarget是当余额为1消逝时间为60秒条件下的target。
* 除非有新区块产生，不然target随时间增大，节点会不断比较hit与target，当hit < target时，产生新区块。
* 节点检验一个新区块是否有效，要检验该区块的generationSignature参数是否确实是产生区块的节点对前一个有效区块generationSignature参数的私钥签名，还要检验新区块的时间戳是否与产生区块的节点之前发布的期望时间吻合，以及期望时间是否按正确的公式计算。
* 每次客户端检测到网络中有有效区块产生，都会重新计算自己的期望时间并向全网发布，所以，只有期望时间离现在非常近时，客户端才有机会真正产生区块。
* 所以，节点间竞争以获取产生新区块的机会，这种机会总体来讲与节点的NXT有效余额成正比，但hit的引入使得每次产生区块的机会分配有了一定的随机性，也即NXT有效余额较小的节点也有机会产生新区块。验证机制中时间因素的加入大大限制了恶意节点操纵网络的自由度。
* 由于能够预测哪个个账号锻造出下一个区块以及什么时候锻造出来。拥有许多账户且拥有大算力的人可以计算出哪个账户最有可能锻造出下一个区块，然后将所有的NXT转移到那个账号里去锻造区块。这对于系统安全构成了一种威胁，所以NXT添加了“成熟”机制，即转入一个账户的NXT需要经过1440个确认（通常需要一天时间）后才能成熟转为有效余额并参与锻造，这种设计不讨人喜欢，但有效减少了NXT受攻击的可能。
* 透明锻造可以临时性地将产生下个区块的节点的锻造能力减少至0。这个特性设计用于阻止拥有90%Nxt数目的节点进行分支或者分叉。因此，如果一个节点拥有90%的NXT而未按照计划产生区块，其它节点就会临时将其锻造能力减少到0以阻止可能的分叉。它的锻造能力就会分配给网络中剩余的节点，因此网络的能力还是100%，所以，不管该潜在的对手它在其它分支上做什么，都会被高级的共识机制（还未披露）所限制。


## 以太坊Casper
* Casper属于以太坊从POW转型到POS的一个优化版POS共识机制。Casper有两个版本，CFFG和CTFG。
* Casper要求验证人将保证金中的大部分对共识结果进行下注。而共识结果又通过验证人的下注情况形成：验证人必须猜测其他人会赌哪个块胜出，同时也下注这个块。如果赌对了，他们就可以拿回保证金外加交易费用，也许还会有一些新发的货币；如果下注没有迅速达成一致，他们只能拿回部分保证金。因此数个回合之后验证人的下注分布就会收敛。
* 此外如果验证人过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，他将被严惩。这条规则确保了验证人只有在非常确信其他人也认为某个块有高概率胜出时才以高概率下注。我们通过这个机制来确保不会出现下注先收敛于一个结果然后又收敛到另外一个结果的情况，只要验证人足够多。
* POW共识同样可以理解为是一个下注机制：矿工选择一个块基于它进行挖矿，也就是赌这个块会成为主链的一部分；如果赌对了，他可以收到奖励，而如果赌错了，他会损失电费。只要所有的矿工都将他们的算力下注到同一条链上，使这条链拥有最多的工作量（即时算力下注的预测，也是算力下注的结果），共识就是安全的。POW中算力赌注的经济价值随着确认数的增加线性增长，而在Casper中验证人可以通过协调使下注比例指数增长，从而使共识快速达到最大安全。
* 验证人对每一个高度上的每一个候选块独立下注，给每个块指定一个胜出概率并公布。通过反复下注，对于每个高度验证人会选出唯一一个胜出块，这个过程也决定了交易(transaction)执行的顺序。如果一个验证人在某个高度公布的概率分布总和大于100%，或者公布了小于0%的概率，或者对一个无效块指定了大于0%的概率，Casper将罚没他的保证金。
* [Tendermint vs. Casper](https://mp.weixin.qq.com/s/9ICNMgyAEjIf_JrDAetvKw)


## DPOS(详见另一篇文章)


## AuxPOW(Auxiliary Proof-of-Work，联合挖矿)
* AuxPOW全称Auxiliary Proof-of-Work，也被称为联合挖矿。目前使用AuxPOW共识算法的币种以NMC（域名币）和DOGE（狗狗币）为主要代表。AuxPOW可以简单的理解为是POW的寄生关系，POW的币种被称为父链（Parent blockchain），寄生在其上的币种被称为辅链（Auxiliary blockchain），父链不需要知道辅链的存在，而辅链需要有协议来支持复用父链的POW结果。在不断进行哈希计算的过程中，当符合父链的难度要求时，父链就挖出一个区块，当符合辅链难度要求时，则辅链挖出一个区块。比如域名币以比特币为父链，狗狗币以莱特币为父链进行挖矿来产生区块。
* AuxPOW协议的实现无需改动父链，而实现Merge Mining的辅链则需要做针对性设计。虽然主链不需要做任何改动，但前提是主链必须支持可编程脚本，比如比特币Coinbase的输入字段，此处只规定了长度限制，留了一片未定义区域，这也是比特币实现类似智能合约的雏形。正因为可以通过写入规定格式的数据，辅链可以解析并认可父链计算出的Hash值。
* AuxPOW协议核心理念相对于POW不同的地方在于POW生产区块，规定只有难度符合要求才算一个合格的区块，AuxPOW协议对区块难度没有要求，但附加两个条件：辅链区块的hash值必须内置于父链区块的Coinbase里；该父链区块的难度必须符合辅链的难度要求；父链和辅链的算法一致。
* AuxPOW将辅链区块的hash值内置于父链的Coinbase，其实是利用父链作存在证明。这样就可以实现间接依靠父链的算力来维护辅链安全。一般来说，父链的算力比辅链大，因而满足父链难度要求的区块一定同时满足辅链难度要求，反之则不成立。这样一来，很多本来在父链达不到难度要求的区块，却达到辅链难度要求。父链增加区块中Coinbase的scriptSig字段：magic字段：用于标识联合挖矿；aux_block_hash字段：表示辅链区块的哈希值（多个辅链时则为所有辅链哈希构造的MerklerRoot）；merkle_size字段：表示辅链数量（一条辅链设置为1）；merkle_nonce字段：表示辅链id（一条辅链设置为0）
* 对于辅链则需要加入5个字段：父链的coinbase的交易数据coinbase_txn；父链区块头的哈希值；父链Coinbase所在MerklerRoot的分支；辅链区块哈希所在MerklerRoot的分支；父链区块头。
* 目前以比特币和莱特币为父链的挖矿币种需要与矿池来对接，父链Coinbase的scriptSig由矿池修改，辅链只需要添加上面5个字段，并对这些字段做验证即可。验证的基本过程是：根据父链区块头和父链区块哈希值验证父链区块头是否符合辅链难度要求；依靠父链coinbase的交易数据、父链Coinbase所在MerklerRoot的分支以及父链区块头，验证辅链Coinbase交易是否真的被包含在父链区块中；依靠辅链区块哈希所在MerklerRoot的分支，以及Coinbase中aux_block_hash字段，验证辅链区块Hash是否内置于父链区块的Coinbase交易中。


## POS + POW
* [DCR: 更民主的比特币继承者](https://juejin.im/post/59ccab6ff265da0647040d28)
* [Decred的pow+pos](http://www.hongico.com/forum.php?mod=viewthread&tid=5969)
* [dcr区块链浏览器](https://mainnet.decred.org/blocks)
* [点点币白皮书](https://peercoin.net/assets/paper/peercoin-paper-cn.pdf)
* [点点币pos实现](http://blog.51cto.com/11821908/2060084)
* [点点币区块链浏览器](https://chainz.cryptoid.info/ppc/)
* 点点币中的POS类似与传统的POW机制，也是基于哈希的不断运算来竞争获得记帐权。点点币POS的主要理念是节点记账权的获得难度与节点持有的权益成反比，这样在一定程度上减少了哈希运算带来的资源消耗，根据每个节点所占代币的比例和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。
* 点点币的POS中有一个叫做币龄（Coin age）的概念，用于给交易排出优先次序，简单地定义为货币的持有时间段，即持有的币数乘以持有币的天数。因为有这个概念这样就产生了持币人的利息，也就是说持币人把代币当作押金放入POS机制中，就有机会产生新区块而得到奖励。POS挖矿所赚取的年化利率为1%。点点币在转账后经过30天才可以进行挖矿，经过90天后，他们成功挖到区块的概率达到最大。总体而言，这个系统中存在一个持币人的集合，他们把手中的代币放入POS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块而言，POS算法在验证者中随机选择一个（选择验证者的权重依据他们投入的代币量，比如一个投入押金为1W代币的验证者被选择的概率是一个投入1K代币验证者的10倍），给他权利产生下一个区块。如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生新区块。与POW一样，POS以最长的链为准。
* 点点币的POS也有挖矿难度的概念，使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大难度越小。当前区块的目标值与前一个区块目标值，前两个区块的时间间隔有关。计算公式：当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60)，由此可见两个区块目标间隔时间为10分钟。
* 点点币的POS也有挖矿难度的概念，使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大难度越小。当前区块的目标值与前一个区块目标值，前两个区块的时间间隔有关。计算公式：当前区块目标值 = 前一个区块目标值 x (1007x10x60 + 2x前两个区块时间间隔) / (1009x10x60)，由此可见两个区块目标间隔时间为10分钟。点点币因为也存在POW共识机制，所以区块被分成两种形式，POW区块及POS区块，也就是说存在混合出块的模式。点点币在交易中新加入了一种特殊的交易称利息币（coinstake）类似于比特币的创币交易（coinbase），coinstake的第一个输入被称为 核心（Kernel），并需要符合某一Hash目标协议，这样就产生了出块的随机性，也就是挖矿。
* DCR采用GO语言编写，它与点点币有一定的不同点，它使用POS机制将社区治理融合到区块链技术中，通过其基于区块链的投票系统（即链上投票）发起对技术与非技术改变的民主投票。
* 先通过矿机处理交易，建立起区块，通过不断的碰撞查找，找到满足一定难度的计算目标的数字后，向网络传播，POW的工作就完成了。接下来达成共识的机制就不同了，POW多是靠全网的节点验证区块，最终以最长的链为主链，挖出来的区块如果最终在主链上就是有效，因此区块是否有效来自几乎全网的共识。这样做的优点是安全，前提是没有大于51%的算力攻击，缺点也显而易见，那就是效率低下。而DCR引入了POS来投票决定刚挖出的区块是否有效，每个区块由一个根据区块头数据决定序列的伪随机算法（Hash256PRNG）选出5张选票进行投票，在至少3张选票通过的情况下区块才被承认有效，可以加到主链上。成功验证区块后得到的奖励为30枚新DCR币，它们将会被分成，60%归POW矿工，30%归POS选票持有人，剩下10%预留给参与软件开发的程序员。
* DCR的持有者可以锁定一定数量的币来购买新鲜选票，选票有过期时间，如果过期了还未被选中去投票的话，会全部返还。购票之后需要等待被矿工挖掘，每个挖出的区块会包含最多20张新鲜选票，这些选票需要等到256个新区块产生后才能成熟（即拥有被选择行使投票权）。为了激励矿工把新鲜选票包含在挖出的区块中，会有一个额外的购票费，留给矿工作为奖励。成熟之后如果选票顺利被选中去投票，系统会返回购票的币并加上奖励。每个区块需要随机选5张成熟选票进行投票验证区块的有效性。票价每144个区块（大约12小时）调整一次，目的是将整个选票池控制在40960张。


## dBFT：小蚁区块链（delegated BFT，授权拜占庭容错机制）

## PBFT：Fabric使用的经典算法(Practical Byzantine Fault Tolerance，实用拜占庭容错算法)

